{
  
    
        "post0": {
            "title": "Tips for making plots",
            "content": "About . This python notebook is a demonstration of some simple codes to make neat plots. I have used these to make plots for my research papers. Some of my friends liked them so I thought to share some tips in this post. I will keep it short and to the point. Also, there are lots of amazing tutorials in the web to make wonderful plots with python. So, don&#39;t just stop here if you dont find what you are looking for. . A Line Plot . Let&#39;s start by plotting some data. . import numpy as np import matplotlib.pyplot as plt . mean, std = 0, 1 num_samples = 1000 y = np.random.normal(mean, std, size=num_samples) plt.plot(y) plt.show() . On staring the above plot for a minute you will easily spot several things which can be improved. The key is to know the terminology associated with the anatomy of a matplotlib plot. Once you know the terms, a simple searching on internet will help you how to incorporate anything you wish into this plot. So, here is the anotomy. . Let&#39;s improve the plot now. . # we import one more package to make minor ticks from matplotlib.ticker import (MultipleLocator, FormatStrFormatter, AutoMinorLocator) fig = plt.subplots(figsize=(16,5)) # (width_in_cms, height_in_cms) # plotting without any care ax = plt.subplot(1,2,1) ax.plot(y) # plotting wiith some care ax = plt.subplot(1,2,2) ax.plot(y) ax.set_xlabel(&#39;SAMPLE INDEX&#39;,fontsize=14) ax.set_ylabel(&#39;A.U.&#39;,fontsize=14) # A.U stands for Arbitrary Units ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.xaxis.set_minor_locator(AutoMinorLocator()) ax.yaxis.set_minor_locator(AutoMinorLocator()) ax.tick_params(which=&#39;both&#39;, width=2) ax.tick_params(which=&#39;major&#39;, length=7) ax.tick_params(which=&#39;minor&#39;, length=4, color=&#39;gray&#39;) plt.xticks(fontsize=13) plt.yticks(fontsize=13) plt.show() . A twin axis line plot . Let&#39;s see by plotting some data. We will also add the p-scrore comparing two bars. . # Create sin and cosine fs = 1000 t = np.arange(0,8000,1)/fs y1 = np.sin(t) y2 = np.cos(t) fig, ax1 = plt.subplots(figsize=(9,4)) color = &#39;tab:red&#39; ax1.set_xlabel(&#39;TIME [in secs]&#39;) ax1.set_ylabel(&#39;sin(t)&#39;, color=color, fontsize=14) ax1.plot(t,y1, color=color,alpha=0.7) # alpha controls the opacity ax1.tick_params(axis=&#39;y&#39;, labelcolor=color) ax1.spines[&#39;top&#39;].set_visible(False) ax1.grid(True) ax1.xaxis.set_minor_locator(AutoMinorLocator()) ax1.yaxis.set_minor_locator(AutoMinorLocator()) ax1.tick_params(which=&#39;both&#39;, width=2) ax1.tick_params(which=&#39;major&#39;, length=7) ax1.tick_params(which=&#39;minor&#39;, length=4, color=&#39;gray&#39;) plt.xticks(fontsize=13) plt.yticks(fontsize=13) # plt.xticks([0,31,60,91,len(sorteddates)-1], # [&#39;11 Jan&#39;,&#39;11 Feb&#39;,&#39;11 Mar&#39;,&#39;11 Apr&#39;,&#39;16 May 2020&#39;],rotation=0) ax2 = ax1.twinx() # instantiate a second axes that shares the same x-axis color = &#39;tab:blue&#39; ax2.set_ylabel(&#39;cos(t)&#39;, color=color,fontsize=14) # we already handled the x-label with ax1 ax2.plot(t,y2,color=color,alpha=0.5) ax2.tick_params(axis=&#39;y&#39;, labelcolor=color) ax2.spines[&#39;top&#39;].set_visible(False) ax1.grid(True) ax2.xaxis.set_minor_locator(AutoMinorLocator()) ax2.yaxis.set_minor_locator(AutoMinorLocator()) ax2.tick_params(which=&#39;both&#39;, width=2) ax2.tick_params(which=&#39;major&#39;, length=7) ax2.tick_params(which=&#39;minor&#39;, length=4, color=&#39;gray&#39;) plt.xticks(fontsize=13) plt.yticks(fontsize=13) # plt.xticks([0,31,60,91,len(sorteddates)-1], # [&#39;11 Jan&#39;,&#39;11 Feb&#39;,&#39;11 Mar&#39;,&#39;11 Apr&#39;,&#39;16 May 2020&#39;],rotation=0) fig.tight_layout() # otherwise the right y-label is slightly clipped plt.show() . A bar plot . Bar plots are useful when we have few variables to plot on x-axis and corresponding values in y-axis. Let&#39;s plot some. First we will define a function to annotate the p-value on top of the bars. . # First we will define a function to show significance values. # I pulled this from internet some time back and now can&#39;t find the reference. If you find do find it, let me know, I will like to add an acknowledgement. # funcs definitions to make significant plot markers def barplot_annotate_brackets(num1, num2, data, center, height, yerr=None, dh=.05, barh=.05, hdist=1,fs=None, maxasterix=None,fsize=14): &quot;&quot;&quot; Annotate barplot with p-values. :param num1: number of left bar to put bracket over :param num2: number of right bar to put bracket over :param data: string to write or number for generating asterixes :param center: centers of all bars (like plt.bar() input) :param height: heights of all bars (like plt.bar() input) :param yerr: yerrs of all bars (like plt.bar() input) :param dh: height offset over bar / bar + yerr in axes coordinates (0 to 1) :param barh: bar height in axes coordinates (0 to 1) :param fs: font size :param maxasterix: maximum number of asterixes to write (for very small p-values) &quot;&quot;&quot; if type(data) is str: text = data else: # * is p &lt; 0.05 # ** is p &lt; 0.005 # *** is p &lt; 0.0005 # etc. text = &#39;&#39; p = .05 while data &lt; p: text += &#39;*&#39; p /= 10. if maxasterix and len(text) == maxasterix: break if len(text) == 0: text = &#39;n. s.&#39; lx, ly = center[num1], height[num1] rx, ry = center[num2], height[num2] if yerr: ly += yerr[num1] ry += yerr[num2] ax_y0, ax_y1 = plt.gca().get_ylim() dh *= (ax_y1 - ax_y0) barh *= (ax_y1 - ax_y0) y = max(ly, ry) + dh barx = [lx, lx, rx, rx] bary = [y, y+barh, y+barh, y] mid = ((lx+rx)/2, y+barh+hdist) plt.plot(barx, bary, c=&#39;black&#39;) kwargs = dict(ha=&#39;center&#39;, va=&#39;bottom&#39;) if fs is not None: kwargs[&#39;fontsize&#39;] = fs plt.text(*mid, text, **kwargs,fontsize=fsize) . Now we will make the bar plot. . # make data x = [] x.append(np.random.normal(10, std, size=num_samples)) x.append(5+x[0]) # scatter plots fig = plt.subplots(figsize=(9, 4)) ax = plt.subplot(1,2,1) ax.scatter(x[0],x[1],color=&#39;green&#39;) ax.set_xlabel(&#39;VAR 1&#39;,fontsize=14) ax.set_ylabel(&#39;VAR 2&#39;,fontsize=14) ax.xaxis.set_minor_locator(AutoMinorLocator()) ax.yaxis.set_minor_locator(AutoMinorLocator()) ax.tick_params(which=&#39;both&#39;, width=2) ax.set_xlim(5,20) ax.set_ylim(5,20) ax.grid(True) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # ax.plot([5,60],[5,60],&#39;--&#39;,color=&#39;black&#39;,alpha=0.25) ax.tick_params(which=&#39;minor&#39;, length=4, color=&#39;gray&#39;) ax = plt.subplot(1,2,2) ax.bar(2,np.mean(x[0]),yerr=np.std(x[0]), align=&#39;center&#39;,alpha=1, ecolor=&#39;black&#39;,capsize=5,hatch=&quot; &quot;,color=&#39;red&#39;,label=&#39;VAR 1&#39;,width=.5) ax.bar(4,np.mean(x[1]),yerr=np.std(x[1]), align=&#39;center&#39;,alpha=1, ecolor=&#39;black&#39;,capsize=5,hatch=&quot;//&quot;,color=&#39;blue&#39;,label=&#39;VAR 2&#39;,width=.5) ax.set_ylabel(&#39;AVERAGE&#39;,fontsize=14) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=14) plt.xticks([2,4], [&#39;VAR 1&#39;,&#39;VAR 2&#39;],rotation=0) ax.set_xlim(1,7) ax.set_ylim(5,19) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # sns.despine() # Call the function barplot_annotate_brackets(0, 1, &#39;p = dummy&#39;, [2,4],[np.mean(x[0]),np.mean(x[1])], dh=.1,barh=.05,fsize=14) plt.tight_layout() plt.show() . A density plot . # here we will use the seaborn package import seaborn as sns sns.set() # Use seaborn&#39;s default style to make attractive graphs sns.set_style(&quot;white&quot;) sns.set_style(&quot;ticks&quot;) fig = plt.subplots(figsize=(8,3)) ax = plt.subplot(1,1,1) sns.distplot(x[0],label=&#39;VAR 1&#39;,color=&#39;red&#39;) sns.distplot(x[1],label=&#39;VAR 2&#39;,color=&#39;blue&#39;) # sns.kdeplot(np.reciprocal(rt_spkr_2[0]), shade=True,color=&#39;red&#39;,label=&#39;eng&#39;) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.set_xlabel(&#39;A.U&#39;,fontsize=13) ax.set_ylabel(&#39;DENSITY&#39;,fontsize=13) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=13) plt.xticks(fontsize=13) plt.yticks(fontsize=13) plt.show() . A 2-D image or spectrogram plot . We will first read a sound file (WAV format). Then we will compute its spectrogram, and follow this up with plotting the time-domain signal and the spectrogram. . from scipy.io import wavfile # package to read WAV file from mpl_toolkits.axes_grid1 import make_axes_locatable # to move placement of colorbar # function to create spectrogram def generate_spectrogram(x,fs,wdur=20e-3,hdur=5e-3): X = [] i = 0 cnt = 0 win = np.hamming(wdur*fs) win = win - np.min(win) win = win/np.max(win) while i&lt;(len(x)-int(wdur*fs)): X.append(np.multiply(win,x[i:(i+int(wdur*fs))])) i = i + int(hdur*fs) cnt= cnt+1 X = np.array(X) Xs = abs(np.fft.rfft(X)) return Xs # read WAV file and plot data [fs, x] = wavfile.read(&#39;./my_sounds/count.wav&#39;) sig = x/np.max(np.abs(x)) taxis = np.arange(0,len(x))/fs fig = plt.subplots(figsize=(6,1)) ax = plt.subplot(1,1,1) ax.plot(taxis,sig) ax.set_xlim(taxis[0]-0.1/2,taxis[-1]) ax.set_ylim(-1,1) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U&#39;) sns.despine(offset = .1,trim=False) # fmt=&#39;png&#39; # plt.savefig(path_store_figure+&#39;IIScConnect_sample_count_sig.&#39;+fmt, dpi=None, facecolor=&#39;w&#39;, edgecolor=&#39;w&#39;, # orientation=&#39;portrait&#39;, papertype=None, format=fmt,transparent=False, bbox_inches=&#39;tight&#39;, pad_inches=None, metadata=None) plt.show() fig, ax = plt.subplots(figsize=(6,4)) Xs = generate_spectrogram(sig,fs,wdur=25e-3,hdur=2.5e-3) XdB = 20*np.log10(Xs.T) XdB = XdB - np.max(XdB) im = ax.imshow(XdB,origin=&#39;lower&#39;,aspect=&#39;auto&#39;,extent = [taxis[0], taxis[-1], 0, fs/2/1e3], cmap=&#39;RdBu_r&#39;,vmin = 0, vmax =-100) divider = make_axes_locatable(ax) colorbar_ax = fig.add_axes([.95, 0.1, 0.015, 0.5]) fig.colorbar(im, cax=colorbar_ax) ax.set_xlim(taxis[0]-0.1/2,taxis[-1]) ax.set_ylim(-.1,4) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;FREQ [in kHz]&#39;) sns.despine(offset = 0.01,trim=False) # plt.savefig(path_store_figure+&#39;IIScConnect_sample_count_spectgm.&#39;+fmt, dpi=None, facecolor=&#39;w&#39;, edgecolor=&#39;w&#39;, # orientation=&#39;portrait&#39;, papertype=None, format=fmt,transparent=False, bbox_inches=&#39;tight&#39;, pad_inches=None, metadata=None) plt.show() . /Users/neeks/miniconda2/envs/py36/lib/python3.6/site-packages/ipykernel_launcher.py:22: WavFileWarning: Chunk (non-data) not understood, skipping it. . A confusion matrix . cf_matrix = np.random.normal(0,1,(5,5)) keys = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;] fig = plt.subplots(figsize=(7,5)) ax = plt.subplot(1,1,1) # sns.set(font_scale=1.4)#for label size sns.heatmap(cf_matrix/np.sum(cf_matrix)*100, annot=True, fmt=&#39;.2g&#39;, cmap=&#39;Blues&#39;, annot_kws={&quot;size&quot;: 13}, cbar_kws={&#39;label&#39;: &#39;RANDOM NUMBERS&#39;})# font size ax.figure.axes[-1].yaxis.label.set_size(10) # fontsize for label on color bar ax.set_xticks(np.arange(len(keys))) ax.set_yticks(np.arange(len(keys))) ax.set_xticklabels(keys,rotation=0,fontsize=13) ax.set_yticklabels(keys,rotation=0,fontsize=13) plt.show() . Adding plot into a paper . The key here is to first create the plot at an aspect ratio as you will like it in the paper. I do this by setting the figsize to appropriate dimensions. . fig = plt.subplots(figsize=(6,4)) # (width_cms,height_cms) . You can also resize the figure in latex but that doesn&#39;t look very nice as the text and numbers inside the figure don&#39;t get appropriately scaled. From python, I save figure as PDF using: . ax.figure.savefig(&#39;name.pdf&#39;, bbox_inches=&#39;tight&#39;) . For more options, there is this: . fmt=&#39;pdf&#39; plt.savefig(&#39;name.&#39;+fmt, dpi=None, facecolor=&#39;w&#39;, edgecolor=&#39;w&#39;, orientation=&#39;portrait&#39;, papertype=None, format=fmt,transparent=False, bbox_inches=&#39;tight&#39;, pad_inches=None, metadata=None) . Sometimes I have to create multiple subplots and also block diagrams. For this I open Keynote (in Mac), and insert the plots (and make any block diagrams) in a slide. Then I export the slide as a PDF (saving in Best form). Subsequently, I crop the white spaces around the exported PDF using pdfcrop command in terminal. Done. . Adding plot into a slide or webpage . I guess JPEG is the smallest file size for a plot/figure. The downside is JPEG is not vector scalable graphics. When you zoom into a JPEG image you will loose on the resolution and see block artifacts, This is not there in PDF and EPS formats. Hence, PDF and EPS format suit academic papers and JPEG/PNG dont. However, JPEG and PNG are good for slides and webpages as you dont want a huge filesize here. . That&#39;s it! . What I presented is some simple codes to make neat plots. These plots are basic line/bar/distribution plots. The matplotlib is quite resourceful to make many more elegant plots. So, if you imagine something, the next step will be to know the term for it, and then see the documentation of matplotlib (or google it) and you may find a lead. .",
            "url": "https://neerajww.github.io/myblog/2020/06/11/plotting_tips.html",
            "relUrl": "/2020/06/11/plotting_tips.html",
            "date": " • Jun 11, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Using Hilbert transform to get signal envelope",
            "content": "First we import some packages. . import numpy as np import scipy.signal as signal import matplotlib.pyplot as plt import seaborn as sns; sns.set() sns.set_style(&quot;white&quot;) sns.set_style(&quot;ticks&quot;) . Next, we define functions to create envelope and carrier signals. . def create_envelope(num_samples,fL_hz=100,N=1000,beta=3): # we will create the envelope by low pass filtering white noise mean = 0 std = 1 taps = signal.firwin(N, fL_hz/nyq_rate, window=(&#39;kaiser&#39;, beta)) x = np.random.normal(mean, std, size=num_samples) x = signal.filtfilt(taps, 1,x) x = (x-np.min(x)) x = x/np.max(x) return x def create_carrier_harmonic(fs=8e3,fc=200,num_samples=1000,ncomps=1): # this will create a harmonic carrier with ncomps harmonics x = [] for i in range(ncomps): x.append(np.sin(2*np.pi*(i+1)*fc*np.arange(0,num_samples,1)/fs)) x = sum(x) x = x/np.max(np.abs(x)) return x def create_carrier_noise(mean=0,std=1,num_samples=1000): # this will create a white noise carrier x = np.random.normal(mean, std, size=num_samples) x = x/np.abs(x) return x . Now we are ready to create amplitude modulated signals, and subsequently, estimate the envelope. . Let&#39;s start with an amplitude modulated tone. . # init filter and signal params fs = 8e3 dur = 5 # signal duration num_samples = int(dur*fs) t = np.arange(0,num_samples,1)/fs nyq_rate = fs / 2.0 width = 5.0/nyq_rate # 5 Hz filter transition width. ripple_db = 60.0 # stop band attenuation N, beta = signal.kaiserord(ripple_db, width) # create envelope fL_hz = 50 envelope = create_envelope(num_samples=num_samples,fL_hz=fL_hz,N=N,beta=beta) # create carrier carrier = create_carrier_harmonic(fs=fs,fc=100,num_samples=num_samples,ncomps=1) # create am-fm signal x = np.multiply(envelope,carrier) # estimate analytic signal ax = signal.hilbert(x) envelope_hat = np.abs(ax) # plt.plot(x) fig = plt.subplots(figsize=(8,4)) ax = plt.subplot(1,1,1) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat,color=&#39;red&#39;,label=&#39;ENVP. EST.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-1,1.75) plt.show() . Let&#39;s make the carrier a sum of 2 harmonics. The carrier is not a tone but a sum of two tones. . # init filter and signal params fs = 8e3 dur = 5 # signal duration num_samples = int(dur*fs) t = np.arange(0,num_samples,1)/fs nyq_rate = fs / 2.0 width = 5.0/nyq_rate # 5 Hz filter transition width. ripple_db = 60.0 # stop band attenuation N, beta = signal.kaiserord(ripple_db, width) # create envelope fL_hz = 50 envelope = create_envelope(num_samples=num_samples,fL_hz=fL_hz,N=N,beta=beta) # create carrier carrier = create_carrier_harmonic(fs=fs,fc=100,num_samples=num_samples,ncomps=2) # create am-fm signal x = np.multiply(envelope,carrier) # estimate analytic signal ax = signal.hilbert(x) envelope_hat = np.abs(ax) # plt.plot(x) fig = plt.subplots(figsize=(8,4)) ax = plt.subplot(1,1,1) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat,color=&#39;red&#39;,label=&#39;ENVP. EST.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-.5,1) plt.show() . The envelope estimated is a poor fit to the true envelope. Can we improve this? One option is to apply a lowpass filter to the estimated envelope. Lets see how does it do. . # init filter and signal params fs = 8e3 dur = 5 # signal duration num_samples = int(dur*fs) t = np.arange(0,num_samples,1)/fs nyq_rate = fs / 2.0 width = 5.0/nyq_rate # 5 Hz filter transition width. ripple_db = 60.0 # stop band attenuation N, beta = signal.kaiserord(ripple_db, width) # create envelope fL_hz = 50 envelope = create_envelope(num_samples=num_samples,fL_hz=fL_hz,N=N,beta=beta) # create carrier carrier = create_carrier_harmonic(fs=fs,fc=100,num_samples=num_samples,ncomps=2) # create am-fm signal x = np.multiply(envelope,carrier) # estimate analytic signal ax = signal.hilbert(x) envelope_hat = np.abs(ax) taps = signal.firwin(N, fL_hz/nyq_rate, window=(&#39;kaiser&#39;, beta)) envelope_hat_filt = signal.filtfilt(taps, 1,envelope_hat) fig = plt.subplots(figsize=(16,4)) ax = plt.subplot(1,2,1) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat,color=&#39;red&#39;,label=&#39;ENVP. EST.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-.5,1) ax = plt.subplot(1,2,2) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat_filt,color=&#39;red&#39;,label=&#39;ENVP. EST. FILT.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-.5,1) plt.show() . We do better with filter but still not perfect. Now, lets make the carrier a broadband white noise instead of tones. . # init filter and signal params fs = 8e3 dur = 5 # signal duration num_samples = int(dur*fs) t = np.arange(0,num_samples,1)/fs nyq_rate = fs / 2.0 width = 5.0/nyq_rate # 5 Hz filter transition width. ripple_db = 60.0 # stop band attenuation N, beta = signal.kaiserord(ripple_db, width) # create envelope fL_hz = 50 envelope = create_envelope(num_samples=num_samples,fL_hz=fL_hz,N=N,beta=beta) # create carrier carrier = create_carrier_noise(mean=0,std=1,num_samples=num_samples) # create am-fm signal x = np.multiply(envelope,carrier) # estimate analytic signal ax = signal.hilbert(x) envelope_hat = np.abs(ax) taps = signal.firwin(N, fL_hz/nyq_rate, window=(&#39;kaiser&#39;, beta)) envelope_hat_filt = signal.filtfilt(taps, 1,envelope_hat) fig = plt.subplots(figsize=(16,4)) ax = plt.subplot(1,2,1) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat,color=&#39;red&#39;,label=&#39;ENVP. EST.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-2,2) ax = plt.subplot(1,2,2) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope,color=&#39;blue&#39;,label=&#39;ENVP. TRUE&#39;) ax.plot(t,envelope_hat_filt,color=&#39;red&#39;,label=&#39;ENVP. EST. FILT.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) plt.xlim(0,0.5) plt.ylim(-2,2) plt.show() . Again, we see that filtered envelope is a better estimate. Now let&#39;s use this approach to obtain an envelope of speech signal. . from scipy.io import wavfile # package to read WAV file # read WAV file and plot data [fs, x] = wavfile.read(&#39;./my_sounds/count.wav&#39;) x = x/np.max(np.abs(x)) t = np.arange(0,len(x))/fs # get analytic signal ax = signal.hilbert(x) envelope_hat = np.abs(ax) taps = signal.firwin(N, fL_hz/nyq_rate, window=(&#39;kaiser&#39;, beta)) envelope_hat_filt = signal.filtfilt(taps, 1,envelope_hat) fig = plt.subplots(figsize=(16,4)) ax = plt.subplot(1,2,1) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope_hat,color=&#39;red&#39;,label=&#39;ENVP. EST.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # plt.xlim(0,0.5) plt.ylim(-1,1.5) ax = plt.subplot(1,2,2) ax.plot(t,x,color=&#39;black&#39;,label=&#39;SIGNAL&#39;) ax.plot(t,envelope_hat_filt,color=&#39;red&#39;,label=&#39;ENVP. EST. FILT.&#39;) ax.set_xlabel(&#39;TIME [in s]&#39;) ax.set_ylabel(&#39;A.U.&#39;) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) # plt.xlim(0,0.5) plt.ylim(-1,1.5) plt.show() . /Users/neeks/miniconda2/envs/py36/lib/python3.6/site-packages/ipykernel_launcher.py:4: WavFileWarning: Chunk (non-data) not understood, skipping it. after removing the cwd from sys.path. . Before we complete lets see how good is our filter. We will apply it on white noise and see the resulting spectrum before and after application. . # plot signal and spectrum x = np.random.normal(0,1,size=num_samples) y = signal.filtfilt(taps, 1,x) fig = plt.subplots(figsize=(16,4)) ax = plt.subplot(1,2,1) ax.plot(np.arange(0,num_samples//2+1,1)/num_samples*fs,10*np.log(abs(np.fft.rfft(x))),label=&#39;SIGNAL&#39;) ax.plot(np.arange(0,num_samples//2+1,1)/num_samples*fs,10*np.log(abs(np.fft.rfft(y))),label=&#39;SIGNAL FILTERED&#39;) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.set_xlabel(&#39;FREQUENCY [in Hz]&#39;,fontsize=14) ax.set_ylabel(&#39;SPECTRUM [in dB]&#39;,fontsize=14) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.ylim(10,80) plt.xticks(fontsize=13) plt.yticks(fontsize=13) ax = plt.subplot(1,2,2) ax.plot(taps) ax.grid(True) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;top&#39;].set_visible(False) ax.set_xlabel(&#39;taps&#39;,fontsize=14) ax.set_ylabel(&#39;A.U.&#39;,fontsize=14) ax.legend(loc=&#39;upper right&#39;,frameon=False,fontsize=12) plt.xticks(fontsize=13) plt.yticks(fontsize=13) plt.show() . No handles with labels found to put in legend. . From the plot it is clear that FIR filter does a good job in removing the spectrum beyond 50 Hz. Lets visualize the filter response and spectrum. . That&#39;s it! . To sum it up, assuming you went through the above, we now understand that . Hilbert transform can be used to estimate signal envelope | The estimation is very accurate for tone signals. In general, it is accurate for narrowband carrier signals. | The estimation performance degrades for wideband carriers, like sum of tones or white noise (broadband signal). | The estimation performance improves on applying a lowpass filter to the envelope estimate. | Such lowpass filtering of the envelope estimate can be also applied to speech signals. | . The above observations can be reasoned from a theoretical angle. I will try to do it another post. .",
            "url": "https://neerajww.github.io/myblog/2020/06/11/hilbert_transform.html",
            "relUrl": "/2020/06/11/hilbert_transform.html",
            "date": " • Jun 11, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi, to know about me you can click here. . This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://neerajww.github.io/myblog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://neerajww.github.io/myblog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}